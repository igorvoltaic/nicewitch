#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Cross-platform algorithm switcher for NiceHash
# It does the same job as NicehashMinerLegacy swithcing between algorithms and miners

# History:
#   Special thanks to Ryan Young (rayoung@utexas.edu, https://github.com/YoRyan) for his idea and part of the code from excavator-driver.py
#   2018-02-19: initial version

__license__ = "GNU GENERAL PUBLIC LICENSE v3.0"

import time
import shlex
import subprocess
import operator
import json
import logging
import signal
import socket
import sys
import urllib.error
import urllib.request
from subprocess import Popen
from urllib.request import Request, urlopen
from time import sleep

# User wallet, worker and region settings
WALLET_ADDR = '37ajn6fULSTfR3HuLdmw9RVPyiJXVrYcQf'
WORKER_NAME = 'rig1'
USER = WALLET_ADDR + '.' + WORKER_NAME 
REGION = 'eu' # eu, usa, hk, jp, in, br

# Path to the directory with mining software
PATH = '/home/$USER/bin'

# Copy & Paste here numbers from benchmark of your miner converted to base unit, H/s
#   H/s   ->  [YOURBECHMARK]
#   kH/s  ->  [YOURBECHMARK]e3 
#   MH/s  ->  [YOURBECHMARK]e6
#   GH/s  ->  [YOURBECHMARK]e9
# if you want to switch off some algorithm just put 0 into the value, or comment it out

MINER = {
 #   'keccak': "echo 'test %s, %s, %s'" % (BINPATH, REGION, USER), #this is meant for testing
    'lyra2rev2': f"{PATH}/ccminer -a lyra2v2 -o stratum+tcp://lyra2rev2.{REGION}.nicehash.com:3347 -u {USER} -p x",
    'neoscrypt': f"{PATH}/ccminer -a neoscrypt -o stratum+tcp://neoscrypt.{REGION}.nicehash.com:3341 -u {USER} -p x",
    'equihash': f"{PATH}/bminer -uri stratum://{USER}:x@equihash.{REGION}.nicehash.com:3357",
    'daggerhashimoto': f"{PATH}/ethminer -SP 2 -U -S daggerhashimoto.{REGION}.nicehash.com:3353 -O {USER} --cuda-parallel-hash 4" %(BINPATH, REGION, USER),
    'daggerhashimoto_pascal': f"{PATH}/claymore/ethdcrminer64 -epool stratum+tcp://daggerhashimoto.{REGION}.nicehash.com:3353 -ewal {USER} -epsw x -esm 3 -allpools 1 -estale 0 -dpool stratum+tcp://pascal.{REGION}.nicehash.com:3358 -dwal {USER} -dcoin pasc -mport 0"
    }

BENCHMARKS = {
#    'keccak': 1685397e11,
#    'nist5': 122.084e6,
    'neoscrypt': 3100e3,
    'lyra2rev2': 156e6,
#    'daggerhashimoto': 113.0e6,
#    'decred': 7493288e3,
#    'cryptonight': 0,
#    'lbry': 741.751e6,
    'equihash': 2000,
#    'pascal': 0,
#    'sia': 3393433e3,
#    'daggerhashimoto_pascal': [82.35e6, 822.5e6],
#    'daggerhashimoto_decred': [81.280e6, 812.2e6],
#    'daggerhashimoto_sia': [82.5e6, 825e6],
#    'daggerhashimoto_keccak': [77.2e6, 770.5e6]
    }

PROFIT_SWITCH_THRESHOLD = 0.1
UPDATE_INTERVAL = 60

EXCAVATOR_TIMEOUT = 10
NICEHASH_TIMEOUT = 20

### here be dragons

def nicehash_multialgo_info():

    #Retrieves pay rates and connection ports for every algorithm from the NiceHash API.
    
    req = Request('https://api.nicehash.com/api?method=simplemultialgo.info', headers={'User-Agent': 'Mozilla/5.0'})
    try:
        response = urllib.request.urlopen(req, None, NICEHASH_TIMEOUT)
    except:
        if check_connection() == False:
            print('[-] No Internet Connection, waiting 5 min before reconnect attempt')
            time.sleep(300)
        else:
            print('[-] NiceHash server is not responding, waiting 60 sec before new attempt')
            time.sleep(UPDATE_INTERVAL)
            return nicehash_multialgo_info()
    query = json.loads(response.read().decode('ascii')) #json.load(response)
    paying = {}
    ports = {}
    for algorithm in query['result']['simplemultialgo']:
        name = algorithm['name']
        paying[name] = float(algorithm['paying'])
        ports[name] = int(algorithm['port'])
    return paying, ports

#Calculating max payout and return the name of the algorithm with the best profit for given benchmarks
def best_algo():
    paying, ports = nicehash_multialgo_info()
    benchmarks = BENCHMARKS
    pay = lambda algo, speed: paying[algo]*speed*(24*60*60)*1e-11
    payrates = {}
    for algo in benchmarks.keys():
        if '_' in algo:
            payrates[algo] = (sum([pay(multi_algo, benchmarks[algo][i]) for i, multi_algo in enumerate(algo.split('_'))]))
        else:
            payrates[algo] = (pay(algo, benchmarks[algo]))
    best_algo_name = max(payrates.items(), key=operator.itemgetter(1))[0]
    best_algo_rate = max(payrates.values())
    return best_algo_name, best_algo_rate

#Checking internet state
def check_connection():
	try:
		host = socket.gethostbyname("yandex.ru")
		s = socket.create_connection((host, 80), 2)
		return True
	except:
		pass
	return False

def main():
    
    benchmarks = BENCHMARKS
    def choose_miner():
        miner = MINER
        args = shlex.split(miner[current_algo_name])
        p = subprocess.Popen(args)
        return p

    current_algo_rate = 0
    current_algo_name = ""

    while True:
        try:
            best_algo_name, best_algo_rate = best_algo()
            print(f"[+] best = {best_algo_name}")
            print(f"[+] current = {current_algo_name}")
            if current_algo_rate == 0:
                current_algo_rate = best_algo_rate
                current_algo_name = best_algo_name
                print(f"[+] new_current = {current_algo_name}")
                p = choose_miner()
                print(f"[+] PID {p.pid}")
            elif current_algo_name != best_algo_name and (best_algo_rate/current_algo_rate >= 1.0 + PROFIT_SWITCH_THRESHOLD):
                p.kill()
                p.wait()
                current_algo_rate = best_algo_rate
                current_algo_name = best_algo_name
                print(f"[*] new_current = {current_algo_name}")
                p = choose_miner()
                print(f"[*] PID {p.pid}")            
        
            time.sleep(UPDATE_INTERVAL)
    
        except KeyboardInterrupt:
            print("\n\n[*] User requested An Interrupt")
            print("[*] Application Exiting ...")
            sys.exit(0)

if __name__ == '__main__':
    main()

